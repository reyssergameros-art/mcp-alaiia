"""
Utilidad para filtrar campos en request bodies basado en criterios dinámicos.

Este módulo proporciona funciones para determinar si un campo debe incluirse
en un request body basándose en análisis de metadatos de Swagger/OpenAPI,
sin usar valores hardcoded.
"""

from typing import Dict, Any, List


# Palabras clave que indican que un campo es read-only o autogenerado
# Esta lista puede extenderse sin modificar la lógica
READONLY_KEYWORDS = [
    # Inglés
    'autogenerated',
    'auto-generated',
    'auto generated',
    'read-only',
    'read only',
    'readonly',
    'generated automatically',
    'automatically generated',
    'server-generated',
    'server generated',
    'system-generated',
    'system generated',
    'auto-increment',
    'autoincrement',
    
    # Español
    'autogenerado',
    'auto-generado',
    'solo lectura',
    'generado automáticamente',
    'generado por el servidor',
    'generado por el sistema',
    'auto-incremento',
    'autoincremento',
    
    # Portugués
    'autogerado',
    'auto-gerado',
    'somente leitura',
    'gerado automaticamente',
    
    # Francés
    'généré automatiquement',
    'lecture seule',
    'auto-généré'
]


def is_field_readonly(field_info: Dict[str, Any]) -> bool:
    """
    Determina si un campo es de solo lectura basándose en su metadata.
    
    Esta función analiza dinámicamente los metadatos del campo para detectar
    indicadores de que es autogenerado o read-only, sin valores hardcoded.
    
    Args:
        field_info: Diccionario con información del campo conteniendo:
                   - description: Descripción del campo (opcional)
                   - name: Nombre del campo (opcional)
                   - required: Si el campo es requerido (opcional)
                   - readOnly: Propiedad OpenAPI 3.0 (opcional)
                   - x-readonly: Extension custom (opcional)
    
    Returns:
        True si el campo es read-only o autogenerado, False en caso contrario
    
    Examples:
        >>> field = {"description": "ID autogenerado del usuario"}
        >>> is_field_readonly(field)
        True
        
        >>> field = {"description": "Nombre del usuario", "required": True}
        >>> is_field_readonly(field)
        False
        
        >>> field = {"description": "Email", "readOnly": True}
        >>> is_field_readonly(field)
        True
    """
    # 1. Verificar propiedad OpenAPI 3.0 readOnly
    if field_info.get('readOnly') is True:
        return True
    
    # 2. Verificar extensión custom x-readonly
    if field_info.get('x-readonly') is True:
        return True
    
    # 3. Analizar descripción del campo
    description = field_info.get('description', '').lower()
    if description:
        # Buscar palabras clave de read-only en la descripción
        for keyword in READONLY_KEYWORDS:
            if keyword in description:
                return True
    
    # 4. Analizar nombre del campo (patrones comunes)
    field_name = field_info.get('name', '').lower()
    if field_name:
        # Patrones comunes de campos autogenerados
        readonly_name_patterns = [
            'id',           # id, userId, orderId
            '_id',          # user_id, order_id
            'uuid',         # uuid, userUuid
            'guid',         # guid, entityGuid
            'created',      # createdAt, created_at
            'updated',      # updatedAt, updated_at
            'modified',     # modifiedAt, modified_at
            'timestamp'     # timestamp, createdTimestamp
        ]
        
        # Solo considerar si el campo NO es requerido
        # (algunos campos como 'email' pueden ser requeridos)
        is_required = field_info.get('required', True)
        if not is_required:
            for pattern in readonly_name_patterns:
                if field_name.endswith(pattern) or pattern in field_name:
                    return True
    
    # 5. Si no se detectó ningún indicador, el campo NO es read-only
    return False


def should_include_field_in_request(
    field_info: Dict[str, Any],
    http_method: str,
    include_optional_fields: bool = True
) -> bool:
    """
    Determina si un campo debe incluirse en un request body.
    
    Esta función aplica lógica dinámica para filtrar campos basándose en:
    - Detección automática de campos read-only
    - Método HTTP
    - Si el campo es requerido u opcional
    
    Args:
        field_info: Diccionario con información del campo
        http_method: Método HTTP (GET, POST, PUT, PATCH, DELETE)
        include_optional_fields: Si se deben incluir campos opcionales normales
                                (default: True)
    
    Returns:
        True si el campo debe incluirse en el request body,
        False si debe excluirse
    
    Examples:
        >>> # Campo autogenerado en POST - debe excluirse
        >>> field = {"name": "id", "required": False, "description": "ID autogenerado"}
        >>> should_include_field_in_request(field, "POST")
        False
        
        >>> # Campo requerido en POST - debe incluirse
        >>> field = {"name": "name", "required": True}
        >>> should_include_field_in_request(field, "POST")
        True
        
        >>> # Campo opcional normal - debe incluirse
        >>> field = {"name": "nickname", "required": False, "description": "Apodo del usuario"}
        >>> should_include_field_in_request(field, "POST")
        True
    """
    # 1. Verificar si el campo es read-only
    if is_field_readonly(field_info):
        # Los campos read-only NUNCA deben incluirse en requests
        return False
    
    # 2. Verificar si el campo es requerido
    is_required = field_info.get('required', False)
    
    # 3. Los campos requeridos siempre se incluyen
    if is_required:
        return True
    
    # 4. Los campos opcionales normales se incluyen según configuración
    # (esto permite flexibilidad en la generación)
    return include_optional_fields


def filter_request_body_fields(
    request_body: Dict[str, Any],
    http_method: str,
    include_optional_fields: bool = True
) -> Dict[str, Any]:
    """
    Filtra campos de un request body eliminando los read-only.
    
    Esta función procesa un diccionario completo de request body y retorna
    solo los campos que deben incluirse según los criterios dinámicos.
    
    Args:
        request_body: Diccionario con todos los campos del request body
        http_method: Método HTTP (POST, PUT, etc.)
        include_optional_fields: Si incluir campos opcionales normales
    
    Returns:
        Diccionario con solo los campos que deben incluirse
    
    Examples:
        >>> body = {
        ...     "id": {"required": False, "description": "Autogenerado"},
        ...     "name": {"required": True, "example": "Test"},
        ...     "nickname": {"required": False, "example": "T"}
        ... }
        >>> filtered = filter_request_body_fields(body, "POST")
        >>> list(filtered.keys())
        ['name', 'nickname']
    """
    if not request_body:
        return {}
    
    filtered_fields = {}
    
    for field_name, field_info in request_body.items():
        if should_include_field_in_request(field_info, http_method, include_optional_fields):
            filtered_fields[field_name] = field_info
    
    return filtered_fields


def get_readonly_fields_report(request_body: Dict[str, Any]) -> Dict[str, Any]:
    """
    Genera un reporte de campos read-only detectados.
    
    Útil para debugging y validación de la detección automática.
    
    Args:
        request_body: Diccionario con todos los campos del request body
    
    Returns:
        Diccionario con estadísticas y lista de campos read-only detectados
    
    Examples:
        >>> body = {
        ...     "id": {"required": False, "description": "ID autogenerado"},
        ...     "name": {"required": True, "example": "Test"}
        ... }
        >>> report = get_readonly_fields_report(body)
        >>> report['readonly_count']
        1
        >>> report['readonly_fields'][0]['field_name']
        'id'
    """
    if not request_body:
        return {
            "total_fields": 0,
            "readonly_count": 0,
            "writable_count": 0,
            "readonly_fields": []
        }
    
    readonly_fields = []
    
    for field_name, field_info in request_body.items():
        if is_field_readonly(field_info):
            readonly_fields.append({
                "field_name": field_name,
                "reason": _get_readonly_reason(field_info),
                "description": field_info.get('description', ''),
                "required": field_info.get('required', False)
            })
    
    return {
        "total_fields": len(request_body),
        "readonly_count": len(readonly_fields),
        "writable_count": len(request_body) - len(readonly_fields),
        "readonly_fields": readonly_fields
    }


def _get_readonly_reason(field_info: Dict[str, Any]) -> str:
    """
    Obtiene la razón por la cual un campo fue detectado como read-only.
    
    Args:
        field_info: Información del campo
    
    Returns:
        String describiendo la razón
    """
    # Verificar propiedad OpenAPI
    if field_info.get('readOnly') is True:
        return "OpenAPI readOnly property"
    
    # Verificar extensión custom
    if field_info.get('x-readonly') is True:
        return "Custom x-readonly extension"
    
    # Verificar descripción
    description = field_info.get('description', '').lower()
    for keyword in READONLY_KEYWORDS:
        if keyword in description:
            return f"Keyword '{keyword}' in description"
    
    # Verificar nombre del campo
    field_name = field_info.get('name', '').lower()
    readonly_patterns = ['id', '_id', 'uuid', 'guid', 'created', 'updated', 'modified', 'timestamp']
    for pattern in readonly_patterns:
        if pattern in field_name and not field_info.get('required', True):
            return f"Field name pattern '{pattern}' and not required"
    
    return "Unknown reason"
